Trees
===========


Tree: A tree has (n) number of child nodes.

Binary Tree: A tree with (two) child nodes.
====================     
      (Tree A)
       
        [50]
      /      \
   [25]      [75]
    /\        /\
 [10][30]  [60][80]

======================

Leaf: A node with no children.

Subtree: A tree within the main tree at a node with it's decendents.

Height: Number of nodes on the longest path from the root to a leaf. If the
tree is empty, then height = 0. Add a the root node to tree, then height = 1.


Full Binary Tree: No missing nodes from max height and full from left to right subtrees.
You cannot add nodes to a full binary tree without increasing its height. The formula for
find the number of nodes at particular height in the binary tree is 2^(height-1). 
It's base two because of max two children. To find the total number nodes in a tree,
2^(h) -1. 

Complete Binary Tree: All nodes are full left and right below the max height of the tree or height -1.
All nodes at height-2 have two children, which are height-1. If height-1 has only one child then,
it's a left child.

Balanced Tree: Left and right subtree are equal or differ in height by +1 or -1 node level.

Maximum height of Binary Tree: Is equal to the number of nodes in the tree. This is
similar to a linked list. Only one child(left or right) per parent.
==============
[a]
 \
  [b]
     \ 
     [c]
        \ 
        [d]
        /
      [e]
==============

Minimum height of Binary Tree: Is height of the binary tree that must be 
true with number nodes in this inequality,  h-1 <  logBASE2 (n + 1) <= h.
If log is not integer, round up.


Start at root and go left retrieving each node until left leaf, recurse back
to parent and retrieve right node. Repeat if more nodes.
Pre-order: 50,25,10,30,75,60,80 

Start at root and go left until left leaf and retrieve, recurse back to parent and
retrieve and reapeat steps until right leaf and retrieve and recurse back to root.
In-order:  10,25,30,50,60,75,80 

Start at root and go left until left leaf and retrieve, go right and retrieve until
right leaf, retrieve, and recurse back to parent and retrieve ... until root.
Post-order: 10,30,25,60,80,75,50


      (Tree A)
       
        [50]
      /      \
   [25]      [75]
    /\        /\
 [10][30]  [60][80]


Searching in a binary tree depends on how well the tree is balanced.

OPERATION  | AVERAGE CASE |  WORST CASE
=======================================
Retrieval:     O(log N)         O(N)

Insertion:     O(log N)         O(N)

Removal:       O(log N)         O(N)

Traversal:     O(N)             O(N)


Most common way to implement a binary tree is with a link-based approach, 
but arrays work well with a prioty queue.



